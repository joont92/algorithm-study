package baekjoon.dp;

/**
 * https://www.acmicpc.net/problem/15990
 *
 * 마지막으로 오는 수가 1이면? 그 앞에 올 수 있는 숫자는 2 또는 3이 된다.
 * 마지막으로 오는 수가 2이면? 그 앞에 올 수 있는 숫자는 1 또는 3이 된다.
 * 마지막으로 오는 수가 3이면? 그 앞에 올 수 있는 숫자는 1 또는 2이 된다.
 * 라는 규칙을 갖고 문제를 풀 것이다.  
 *  
 * 점화식은 이차원 배열로 구성이 되고,
 * D[n][i] = 마지막에 오는 수가 i일 때, 1,2,3의 합으로 정수 n을 만드는 경우의 수(반복되지 않고)
 * 마지막에 오는 수가 1일떄, 2일때, 3일때의 경우의 수를 모두 더한 것이 결과가 되므로
 * result = D[n][1] + D[n][2] + D[n][3] 이 된다
 *  
 * D[n][1] = D[n-1][2] + D[n-1][3]
 * > 마지막에 오는 수가 1이니까, 그 앞에 수는 2,3 만 올 수 있다. 여기서 이미 마지막에 1을 더했으니, n 에서는 1을 빼줘야 한다
 * D[n][2] = D[n-2][1] + D[n-2][3]
 * D[n][3] = D[n-3][1] + D[n-3][2]
 *
 *
 * n 이 10이라고 가정하면,
 * 1. 마지막에 1이 올 수 있는 경우의 수
 * D[10][1] = D[9][2] + D[9][3] // 9에 대해 마지막에 2가 올 수 있는 경우의 수 + 마지막에 3이 올 수 있는 경우의 수
 * D[9][2] = D[7][1] + D[7][3]
 * D[9][3] = D[6][1] + D[6][2]
 * D[6][1] = D[5][2] + D[5][3]
 * ...
 * 2. 마지막에 2가 올 수 있는 경우의 수
 * D[10][2] = D[9][1] + D[9][3]
 * ...
 * 3. 마지막에 3이 올 수 있는 경우의 수
 * D[10][3] = ...
 */
public class _1_2_3_더하기5 {
    int mod = 1_000_000_009;
    long[][] array;

    public _1_2_3_더하기5() {
        array = new long[100001][4];

        array[1][1] = 1;
        array[2][2] = 1;
        array[3][1] = 1;
        array[3][2] = 1;
        array[3][3] = 1;

        for (int i = 4; i <= 100000; i++) {
            array[i][1] = (array[i - 1][2] + array[i - 1][3]) % mod;
            array[i][2] = (array[i - 2][1] + array[i - 2][3]) % mod;
            array[i][3] = (array[i - 3][1] + array[i - 3][2]) % mod;
        }
    }

    public long bottomUp(int n) {
        return (array[n][1] + array[n][2] + array[n][3]) % mod;
    }
}